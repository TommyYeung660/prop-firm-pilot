import asyncio
import os
import sys
from pathlib import Path

from src.config import load_config
from src.decision_store.sqlite_store import DecisionStore
from src.decision.agent_bridge import AgentBridge
from src.decision.schemas import TradeIntent
from src.signal.scanner_bridge import ScannerBridge


async def test_e2e_real_scanner():
    """
    Test E2E Pipeline:
    1. Run real qlib_market_scanner to generate signals.
    2. Save signals to DB as TradeIntents.
    3. Claim intent and pass to TradingAgents (LLM).
    4. Save decision back to DB.
    """
    print("=== Phase 1c: Real Scanner to LLM E2E Test ===")

    # 1. Setup Config & Store
    config = load_config("config/e8_signature_50k.yaml")
    store = DecisionStore(":memory:")

    # We'll use a specific date for testing backtest flow
    # or leave it None to run the scanner for the latest available date
    test_date = "2026-02-12"

    # 2. Run Real Scanner
    print(f"\n[Step 1] Running qlib_market_scanner for {test_date}...")
    scanner = ScannerBridge(
        scanner_path=config.scanner.project_path, topk=config.scanner.topk, profile="fx"
    )

    # This will call `uv run python -m src.main --profile fx --end 2026-02-12`
    # inside the ../../qlib_market_scanner directory
    signals = scanner.run_pipeline(date=test_date)

    if not signals:
        print("[ERROR] No signals generated by the scanner. Exiting.")
        return

    print(
        f"[SUCCESS] Scanner generated {len(signals)} signals. Top signal: {signals[0].instrument}"
    )

    # 3. Insert Top Signal into DecisionStore
    top_signal = signals[0]
    print(f"\n[Step 2] Inserting Top Signal ({top_signal.instrument}) into DecisionStore...")

    intent = TradeIntent(
        trade_date=test_date,
        symbol=top_signal.instrument,
        source="scanner",
        scanner_score=top_signal.score,
        scanner_confidence=top_signal.confidence,
        scanner_score_gap=top_signal.score_gap,
        scanner_drop_distance=top_signal.drop_distance,
        scanner_topk_spread=top_signal.topk_spread,
    )
    store.insert_intent(intent)
    print(f"[SUCCESS] Created Intent ID: {intent.id}")

    # 4. Claim the Intent
    print("\n[Step 3] Worker claiming intent...")
    claimed = store.claim_next_pending("test_worker")
    if not claimed:
        print("[ERROR] Failed to claim intent!")
        return
    print(f"[SUCCESS] Claimed Intent: {claimed.symbol} (Score: {claimed.scanner_score:.4f})")

    # 5. AgentBridge (LLM Decision)
    print("\n[Step 4] Running LLM Decision Engine (TradingAgents)...")
    print("Note: Using ['macro'] analyst only for faster testing.")
    bridge = AgentBridge(
        agents_path=config.agents.project_path,
        selected_analysts=["macro"],  # Use only macro to make it fast for testing
        config=config.agents.model_dump(),
    )

    decision = await bridge.decide_async(
        symbol=claimed.symbol,
        trade_date=claimed.trade_date,
        qlib_data={
            "score": claimed.scanner_score,
            "confidence": claimed.scanner_confidence,
            "score_gap": claimed.scanner_score_gap,
            "drop_distance": claimed.scanner_drop_distance,
            "topk_spread": claimed.scanner_topk_spread,
        },
    )

    print(f"\n[SUCCESS] Decision Result for {decision.symbol}:")
    print(f"Action: {decision.decision}")

    # 6. Save Decision back to store
    print("\n[Step 5] Updating Intent in DecisionStore...")
    store.update_intent_decision(
        intent_id=claimed.id,
        side=decision.decision,
        sl_pips=20.0,
        tp_pips=40.0,
        risk_report=decision.risk_report[:500] + "..."
        if decision.risk_report
        else "No specific reasoning",
        state_json="{}",
    )

    # 7. Verify Store
    updated = store.get_intent(claimed.id)
    print("\n=== Final Intent Status in DB ===")
    print(f"ID:       {updated.id}")
    print(f"Symbol:   {updated.symbol}")
    print(f"Status:   {updated.status}")
    print(f"Decision: {updated.suggested_side}")
    print(f"Reasoning snippet:\n{updated.agent_risk_report}")
    print("=================================")


if __name__ == "__main__":
    # Workaround for Windows asyncio event loop policy
    if sys.platform == "win32":
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

    try:
        asyncio.run(test_e2e_real_scanner())
    except KeyboardInterrupt:
        print("\nTest interrupted by user.")
